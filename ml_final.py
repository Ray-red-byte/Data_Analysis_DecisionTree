# -*- coding: utf-8 -*-
"""ML_FINAL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pX88jw7IZtaM7JrkdCiRstoOsXotrz-r

#<font size=8>Packages
"""

from collections import Counter
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import chi2
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, classification_report, accuracy_score
from bs4 import BeautifulSoup
import concurrent.futures
import time
import random
from joblib import Parallel, delayed
import re
from tqdm import tqdm
import nltk
nltk.download('omw-1.4')
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from nltk.stem import WordNetLemmatizer
lemmatizer = WordNetLemmatizer()

from keras.preprocessing import sequence
from keras.preprocessing.text import Tokenizer
from keras.utils import pad_sequences

import warnings
warnings.filterwarnings('ignore', category=UserWarning, module='bs4')

nltk.download('stopwords')
nltk.download('wordnet')
nltk.download('punkt')

from google.colab import drive

drive.mount('/content/gdrive/', force_remount=True)

"""#<font size=8>Functions"""

def read_file(path):
    rawdata = pd.read_csv(path, header=0, delimiter='\t', encoding= 'unicode_escape')
    return rawdata

def preprocess_data(df):
    reviews = []
    for raw in tqdm(df):
        text = BeautifulSoup(raw, 'lxml').get_text()
        only_text = re.sub('[^a-zA-Z]', ' ', text)
        words = word_tokenize(only_text.lower())
        stops = set(stopwords.words('english'))
        non_stopwords = [word for word in words if not word in stops]
        lemma_words = [lemmatizer.lemmatize(word) for word in non_stopwords]
        lemma_words = " ".join(lemma_words)
        reviews.append(lemma_words)
    return reviews

def tokenizer_preprocess(list_X_train, list_X_val):
    unique_words = set()
    len_max = 0
    for sent in tqdm(list_X_train):
        unique_words.update(sent)
        if len_max < len(sent):
            len_max = len(sent)
    len(list(unique_words)), len_max

    tokenizer = Tokenizer(num_words=len(list(unique_words)))
    tokenizer.fit_on_texts(list(list_X_train))                   #Use train_data to fit

    X_train = tokenizer.texts_to_sequences(list_X_train)
    X_train = pad_sequences(X_train, maxlen=len_max)

    X_val = tokenizer.texts_to_sequences(list_X_val)
    X_val = pad_sequences(X_val, maxlen=len_max)

    return X_train, X_val

#cross_validation with k fold
def cross_val(model, X_train, y_train, k=10):
  fold = (X_train.shape[0])/k
  accs = []
  for i in range(k):
    thresh_left, thresh_right = round((i)*fold), round((i+1)*fold)

    if thresh_right < X_train.shape[0] and thresh_left < X_train.shape[0]:
      val_x, val_y = X_train[thresh_left:thresh_right], y_train[thresh_left:thresh_right]
      train_x, train_y = np.concatenate([X_train[:thresh_left], X_train[thresh_right:]]), np.concatenate([y_train[:thresh_left], y_train[thresh_right:]])
    else:
      val_x, val_y = X_train[thresh_left:], y_train[thresh_left:]
      train_x, train_y = X_train[:thresh_left], y_train[:thresh_left]

    model.fit(train_x, train_y)
    prediction = model.predict(val_x)
    acc = accuracy_score(prediction, val_y)
    accs.append(acc)

  return np.mean(accs)

def report(predictions, y_test):
    print('Accuracy: %s' % accuracy_score(y_test, predictions))
    print('Confusion Matrix:')
    print(confusion_matrix(y_test, predictions))
    print('Classification Report:')
    print(classification_report(y_test, predictions))

"""#<font size=8>Dataset1
<font size=5>1. Read the data \
<font size=3.5>• dataset1 : x_train data, x_test data, y_train data

"""

#Put the Test data
train_x_test = pd.read_csv('./gdrive/MyDrive/Dataset1/X_test_1.csv')

#Put the Train x_data and y_data
train_x_train = pd.read_csv('./gdrive/MyDrive/Dataset1/X_train_1.csv')
train_y_train = pd.read_csv('./gdrive/MyDrive/Dataset1/y_train_1.csv')
train_data = pd.concat([train_x_train, train_y_train], axis=1)

"""<font size=5>2. Data exploration\
<font size=3.5>• overview
"""

print('------------------------Dataset1----------------------')
train_x_test.describe()
train_data.describe()

"""<font size=5>3. Show missing value before preprocessing\
<font size=3.5>• The all features' missing value ratio are less than 6%, so no need to drop.
"""

train_data.isnull().sum()/len(train_data)

"""<font size=5>4. Drop the duplicated data\
<font size=3.5>• We have to drop the duplicated instances, because they may cause bias.</font>
"""

train_x_test.drop_duplicates(inplace=True)
train_data.drop_duplicates(inplace=True)
train_data.describe()

"""<font size=5>5. Show the missing value ratio in each feature\
<font size=3.5>• After drop the duplicated data, the missing value ratio still remain acceptable range
"""

X_train = train_data.drop("class", axis=1)
y_train = train_data["class"]

X_train.isnull().sum()/X_train.shape[0]

"""<font size=5>6. As class histgram below, target value are imbalance, 5,6 are dominate."""

y_train.value_counts(normalize=True)
sns.histplot(data=y_train)

"""<font size=5>7. Univariate Analysis\
<font size=3.5>
• The free_sulfur_dioxide, total_sulfur, and sulphates are positive skew.
"""

f, axs = plt.subplots(nrows=4, ncols=3, figsize=(18, 15))
for ind, col in zip(axs.flatten()[:-1], X_train.columns):
    sns.histplot(ax=ind, x=col, data=train_data, hue="class", stat="probability", palette="Set2", kde=True)

"""<font size=5>8. Bivariate Analysis"""

sns.pairplot(train_data, palette="Set2", hue="class")

"""<font size=3.5>• The heatmap below show citric_acid and fixed_acidity, fixed_acidity and density are high correlation.\
• The class and alcohal are the higest correlation, 0.49.
"""

sns.heatmap(train_data.corr(), annot=True, fmt='.2f', cmap="Blues")

"""<font size=5>9. Fill train_data missing value with group_mean, test_data with column_mean"""

train_data = train_data.groupby("class").transform(lambda x: x.fillna(x.mean()))
train_data = pd.concat([train_data, y_train], axis=1)
train_data.isnull().sum()/len(train_data)

train_x_test = train_x_test.fillna(train_x_test.mean())

train_data.describe()

"""<font size=5>10. The outliers\
<font size=3.5>• The residual_sugar and chlorides have the most outlier.
"""

f, axs = plt.subplots(nrows=4, ncols=3, figsize=(18, 15))
for ind, col in zip(axs.flatten()[:-1], X_train.columns):
    sns.boxplot(ax=ind, x=X_train[col])

"""<font size=3.5>• remove the outliers"""

for col in train_data.columns:
  if col == 'class':
    continue
  n_std = 1.5
  mean = train_data[col].mean()
  sd = train_data[col].std()

  df = train_data[(train_data[col] <= mean+(n_std*sd)) & (train_data[col] > mean-(n_std*sd))]

train_data = df
train_data.describe()

train_data.to_csv('./gdrive/MyDrive/Dataset1/processed_train_dataset1.csv')
train_x_test.to_csv('./gdrive/MyDrive/Dataset1/processed_test_dataset1.csv')

"""#<font size=8>Dataset2
<font size=5>1. Read the data \
<font size=3.5>• dataset2 : phrase_train, phrase_test data, sentimental_train data
"""

#Put the Test data
df_phrase_test = read_file('./gdrive/MyDrive/Dataset2/X_test_2.csv')

#Put the Train x_data and y_data
df_phrase_train = read_file('./gdrive/MyDrive/Dataset2/X_train_2.csv')
df_sentimental_train = read_file('./gdrive/MyDrive/Dataset2/y_train_2.csv')

len_train, len_test = df_phrase_train.shape[0], df_phrase_test.shape[0]
X, y = pd.concat([df_phrase_train['Phrase'], df_phrase_test['Phrase']], axis=0), df_sentimental_train['Sentiment']

"""<font size=5>2. Data exploration\
<font size=3.5>• overview
"""

print('------------------------Dataset2----------------------')
print(df_phrase_train.describe())
print(df_phrase_test.describe())
print(df_sentimental_train.describe())

"""<font size=5>3. The distribution of 5 classes with different length \
<font size=3.5>• the positive contain the most different phrase length \
<font size=3.5>• the neutral contain the most intensive phrase length
"""

#Distribution of length of each class
df_phrase_train['PhraseLength']=df_phrase_train['Phrase'].apply(lambda x: len(x))
df_phrase_train.sort_values(by='PhraseLength', ascending=False).head()

plt.figure(figsize=(16,7))
bins=np.linspace(0,200,50)
plt.hist(df_phrase_train[df_sentimental_train['Sentiment']==0]['PhraseLength'],bins=bins,density=True,label='negative')
plt.hist(df_phrase_train[df_sentimental_train['Sentiment']==1]['PhraseLength'],bins=bins,density=True,label='somewhat negative')
plt.hist(df_phrase_train[df_sentimental_train['Sentiment']==2]['PhraseLength'],bins=bins,density=True,label='neutral')
plt.hist(df_phrase_train[df_sentimental_train['Sentiment']==3]['PhraseLength'],bins=bins,density=True,label='somewhat positive')
plt.hist(df_phrase_train[df_sentimental_train['Sentiment']==4]['PhraseLength'],bins=bins,density=True,label='positive')
plt.xlabel('Phrase length')
plt.legend()
plt.show()

"""<font size=5>4. The distribution of class\
<font size=3.5>• class 2 is the largest amount follow by class 3
"""

plt.hist(y, bins=100)
plt.show()

"""<font size=5>5. Preprocess the data\
<font size=3.5>• Remove HTML tags using BeautifulSoup\
   • Keep only alphabetic characters using a regular expression\
   • Tokenize the text into individual words\
   • Remove stopwords (NLTK library)\
   • Perform lemmatization on the words (NLTK library)

"""

train_x_text = preprocess_data(X)

"""<font size=3.5>• Use TF-IDF(term frequency–inverse document frequency) to give each words a score that is important to the document\
.![tfidf.png](data:image/png;base64,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)\
(picture:https://medium.com/%E6%B7%B1%E6%80%9D%E5%BF%83%E6%80%9D/ml-%E7%94%A8%E5%9C%A8nlp-%E7%9A%84-tf-idf-51dac088a79)
"""

#Select top 1000 features in Tfidf, since the scarcely occur word will be eliminated
TF = TfidfVectorizer(max_features=1000)
TF_data = TF.fit_transform(train_x_text)

#Split the concate_data into original train and test
TF_train, TF_test = TF_data[:len_train], TF_data[len_train:]

"""#<font size=8>Node and Decision tree"""

class Node:
    '''
        The information of node
        1. The location of feature
        2. The threshold to partition
        3. if reach leaf_node then return value
    '''
    def __init__(self, feat_loc=None, threshold=None, left=None, right=None, value=None, depth=None):
        self.feat_loc = feat_loc
        self.threshold = threshold
        self.left = left
        self.right = right
        self.value = value
        self.depth = depth

    def leaf(self):
        if self.value is not None:
            return self.value

class Decision_Tree:

    def __init__(self, max_depth=None, min_samples=None, feat=None, n_job=-1, random_n_feat=10, select_function="entropy"):  #傳入的Data設定DT的邊界條件
        '''
            The hyperparameter of DT
            1. max_depth of the tree
            2. min_sample of each node
            3. numbers of features
            4. n_job of the cores of paralleling select best_feature and best_threshold
            5. random_n_feat of the original features of Data
            5. select_function is the criterion to calculate Parent and Child node
        '''
        self.max_depth = max_depth
        self.min_samples = min_samples
        self.feat = feat
        self.n_job = n_job
        self.random_n_feat = random_n_feat
        self.tree = None
        self.evaluation = None

        if select_function == 'entropy':
            self.evaluation = self.entropy
        if select_function == 'Gini':
            self.evaluation = self.Gini

    #Entropy
    def entropy(self, y):
        y = y.flatten()
        unique, counts = np.unique(y, return_counts=True)
        if len(unique) == 0:
            return 0
        total = np.sum(counts)
        return -np.sum(np.log2(counts/total))
        # return -np.sum([((j/total)*np.log2(j/total)) for j in counts if j > 0])

    #Gini
    def Gini(self, y):
        y = y.flatten()
        unique, counts = np.unique(y, return_counts=True)
        total = np.sum(counts)
        return 1 - np.sum([(i/total) for i in counts])

    def fit(self, X, y):
        #Random select the number of feature to be selected
        n_features = self.feat

        self.tree = self._grow_tree(X, y, n_features)

    def predict(self, test_x):
        all_prediction = []

        #Iteratively get each instance in test_x
        for i in test_x:

            #Because the data type I use include sparse metrix and ndarray.
            if isinstance(i, np.ndarray):
              x = i.flatten()
            else:
              x = i.toarray().flatten()

            prediction = self._classify(x, self.tree)
            all_prediction.append(prediction)

        return np.array(all_prediction)

    def _classify(self, each_test_data, node):

        #Stopping Criterion, if the test instance reach the leaf_node
        if node.leaf() is not None:
            return node.value

        #If the test instance is smaller than node threshold, go to left, vice versa.
        if each_test_data[node.feat_loc] <= node.threshold:
            return self._classify(each_test_data, node.left)

        return self._classify(each_test_data, node.right)

    def _grow_tree(self, x, y, n_features, depth = 0):

        #Stopping Criterion
        unique, counts = np.unique(y, return_counts=True)
        if (len(y) <= self.min_samples) or (depth > self.max_depth) or (len(counts) == 1):
          leaf_value = self._leaf_value(y)
          return Node(value=leaf_value, depth=depth)

        #Find the best feature and threshold based on largest information gain
        selected_feature, selected_threshold = self._selected_feature_threshold(x, y, n_features)

        #Split the data based on the best feature and threshold I find
        right, left = self._split(x, selected_feature, selected_threshold)

        #Somtimes, there's the probability that the partition cause to empty node
        if right.shape[0] == 0 or left.shape[0] == 0:
          leaf_value = self._leaf_value(y)
          return Node(value=leaf_value, depth=depth)

        left_x, left_y = x[left, :], y[left]
        right_x, right_y = x[right, :], y[right]

        #After classify the instance, go to the lower node
        l = self._grow_tree(left_x, left_y, n_features, depth + 1)
        r = self._grow_tree(right_x, right_y, n_features, depth + 1)

        return Node(selected_feature, selected_threshold, l, r, depth=depth)

    def _leaf_value(self, y):

        #Calculate the value of the node, based on the most frequency value
        y = y.flatten()
        counter = Counter(y)
        value = counter.most_common(1)[0][0]
        return value

    def _split(self, x, column, split_point):

        #Split the instances, set the split_point as threshold to separate.
        left = np.argwhere(x[:, column] <= split_point)
        right = np.argwhere(x[:, column] > split_point)

        return right[:, 0], left[:, 0]

    def _selected_feature_threshold(self, x, y, n_features):
        target = y

        #Random select feature in each node
        n_features = random.sample(n_features, self.random_n_feat)

        #Compute the largest IG(information gain) among all instances in each column of feature
        def compute_ig(column, target):
          best_IG, best_feature, best_split_point = 0, -1, -1

          if isinstance(x[:, column], np.ndarray):
            nonzero_rows = np.unique(x[:, column]).flatten()
            min_value = np.mean(x[:, column])
          else:
            nonzero_rows = np.unique(x[:, column].toarray()).flatten()
            min_value = 0


          for split_point in nonzero_rows:
            if split_point == min_value or split_point == 0:
              continue

            #Use the target which is before splitting
            parent_entropy = self.evaluation(target)

            #Use the x_data and the selected split_point and selected feature to split
            right_id, left_id = self._split(x, column, split_point)
            left, right = y[left_id], y[right_id]
            IG = self._information_gain(parent_entropy, left, right)

            #if the IG in the selected threshold higher than previous largest one,
            #Change 1.best_IG, 2.best_feature, 3.best_split_point
            if abs(IG) > best_IG:
              best_IG = abs(IG)
              best_feature = column
              best_split_point = split_point

          return best_IG, best_feature, best_split_point

        #The result save all best IG, feature, threshold among all  features.
        #Use the n_jobs CPU_CORES to accelerate the code
        result = Parallel(n_jobs=self.n_job, verbose=20)(delayed(compute_ig)(column, target=target) for column in n_features)

        #Select the best IG, feature, threshold in best feature, according to IG
        max_IG_id = np.argmax(result, axis=0)
        best_feature, best_split_point = result[max_IG_id[0]][1], result[max_IG_id[0]][2]

        return best_feature, best_split_point

    def _information_gain(self, parent_entropy, left, right):
        #Information of Parent minus Information of Child
        portion_l = len(left)/(len(left) + len(right))
        portion_r = len(right)/(len(left) + len(right))

        #Evalution depends on the user's input.
        child_entropy = portion_l*self.evaluation(left) + portion_r*self.evaluation(right)
        IG = parent_entropy - child_entropy
        return IG

"""#<font size=8>Training
<font size=5>Parameter: \
<font size=4>1. min_samples = 10 \
<font size=4>2. max_depth  = 10

<font size=5>Split the data into train and test
"""

#Split the train into train_x and train_y(target)
train = train_data.to_numpy()
x_train, y_train = train[:, :11], train[:, -1]

#Prepare X_test_1
X_test_1 = train_x_test.to_numpy()

#Split the train_x and train_y into train_x, test_x, train_y, test_y, stratify according to train_y, because of imbalanced class
X_train_1, X_val_1, y_train_1, y_val_1 = train_test_split(x_train, y_train, test_size=0.2, stratify=y_train)

#Prepare X_test_2
X_test_2 = TF_test

#Split the TF_train into train and test
X_train_2, X_val_2, y_train_2, y_val_2 = train_test_split(TF_train, y, test_size=0.2, stratify=y)
y_train_2, y_val_2 = y_train_2.to_numpy(), y_val_2.to_numpy()

"""<font size=5>Dataset1"""

#Use entropy criteria
DT_entropy_1 = Decision_Tree(max_depth=10, min_samples=10, random_n_feat=11, feat=range(X_train_1.shape[1]), select_function='entropy')
DT_entropy_1.fit(X_train_1, y_train_1)

#Use Gini criteria
DT_Gini_1 = Decision_Tree(max_depth=10, min_samples=10, random_n_feat=11, feat=range(X_train_1.shape[1]), select_function='Gini')
DT_Gini_1.fit(X_train_1, y_train_1)

"""<font size=5>Dataset2"""

#Use entropy criteria
DT_entropy_2 = Decision_Tree(max_depth=10, min_samples=10, random_n_feat=100, feat=range(X_train_2.shape[1]), select_function='entropy')
DT_entropy_2.fit(X_train_2, y_train_2)

#Use Gini criteria
DT_Gini_2 = Decision_Tree(max_depth=10, min_samples=10, random_n_feat=100, feat=range(X_train_2.shape[1]), select_function='Gini')
DT_Gini_2.fit(X_train_2, y_train_2)

"""#<font size=8>Evaluation
<font size=4>. Method (confusion metrix, f1-score, recall)

<font size=5>Dataset1 :

<font size=4>1.Compare two criterion (entropy, Gini)
"""

Prediction_entropy_1 = DT_entropy_1.predict(X_val_1)
Prediction_Gini_1 = DT_Gini_1.predict(X_val_1)

print('--------------------------Entropy Dataset1-----------------------')
report(Prediction_entropy_1, y_val_1)
print(Prediction_entropy_1)
print('----------------------------Gini Dataset1-----------------------')
report(Prediction_Gini_1, y_val_1)
print(Prediction_Gini_1)

x = Prediction_entropy_1
pd.DataFrame(x).to_csv('./gdrive/MyDrive/Dataset1/dataset1_prediction.csv')

"""<font size=4>2. Test Dataset1"""

Prediction_entropy_test = DT_entropy_1.predict(X_test_1)
print('--------------------------Entropy Dataset1 Test-----------------------')
# report(Prediction_entrop_test, 'Test target')
print(Prediction_entropy_test)

Prediction_Gini_test = DT_Gini_1.predict(X_test_1)
print('----------------------------Gini Dataset1 Test-----------------------')
# report(Prediction_Gini_test, 'Test target')
print(Prediction_Gini_test)

"""<font size=5>Dataset2 :

<font size=4>1.Compare two criterion (entropy, Gini)
"""

Prediction_entropy_2 = DT_entropy_2.predict(X_val_2)
Prediction_Gini_2 = DT_Gini_2.predict(X_val_2)

print('--------------------------Entropy Dataset2 Validation-----------------------')
report(Prediction_entropy_2, y_val_2)
print(Prediction_entropy_2
      )
print('----------------------------Gini Dataset2 Validation-----------------------')
report(Prediction_Gini_2, y_val_2)
print(Prediction_Gini_2)

"""<font size=4>2. Test Dataset2"""

Prediction_entropy_test_2 = DT_entropy_2.predict(X_test_2)
print('--------------------------Entropy Dataset2 Test-----------------------')
# report(Prediction_entrop_test_2, 'Test target')
print(Prediction_entropy_test_2)

Prediction_Gini_test_2 = DT_Gini_2.predict(X_test_2)
print('----------------------------Gini Dataset2 Test-----------------------')
# report(Prediction_Gini_test_2, 'Test target')
print(Prediction_Gini_test_2)